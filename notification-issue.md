p172
알림 시스템 설계 중
개략적 설계안에서 작업서버가 장애가 발생하였을때 대응 방안

책에서 제시한것 :
작업 서버가 메시지를 처리하다 실패하면 메시지를 다시 큐에 넣어 재시도.
Dead Letter Queue (장애가 발생한 메시지들을 모아둔 큐) 로 분리해서 저장 해두고 재처리


추가 방법:
작업 서버를 수평적 확장으로 구성

메시지 큐에 쌓인 작업을 여러 서버가 나눠서 꺼내가기, 한 서버가 죽어도 다른 서버가 대신한다.

```
[알림 서버]  
     ↓  
[메시지 큐]  
     ↓ (Pull) 
[작업 서버 1] [작업 서버 2] [작업 서버 3] ...
```

작업서버 여러대가 큐를 감시
하나의 메시지는 단 하나의 작업 서버만 가져감 (중복x)

장점

서버 하나가 장애가 발생해도 문제없음
큐에 쌓인 작업을 병렬로 처리해서 처리속도가 빠름
확장성이 좋음, 트래픽 대응에도 좋음


! 한 메시지 = 한서버의 원칙을 지키는 방법
Consumer Group
서버들을 하나의 그룹으로 묶어야함(Kafka, RabbitMQ 에서 기본적으로 제공)

Ack (확인 응답)
서버가 메시지 처리완료를 큐에 알려야 다른 서버가 가져가지 않음


중복이 발생할 수 있는 경우

1. 서버가 메시지를 가져간 직후 죽음
큐 입장에서는 이 서버가 작업했는지 안했는지 알 수 없음
일정 시간이 지나면 다시 같은 메시지를 다른 서버에게준다(Visibility Timeout)

2. Ack 전송 실패
네트워크 오류 등으로 Ack 가 실패하면 큐는 오해하고 재전송할 수 있음

따라서 이론상 하나만 처리라고 하지만, 실무에서는 중복 소비가 발생할 수 있음


! 막는 방법

멱등성으로 처리
같은 작업을 여러 번 해도 결과가 한번만 일어나게 만든다

1. 메시지 고유 ID부여
2. 작업 서버가 처리하기 전에 ID를 보고 이미 처리한건지 체크
3. 처리 후에는 처리 완료 상태 저장
  - 캐시에다가
  
